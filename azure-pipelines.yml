trigger:
  branches:
    include:
    - main
  paths:
    include:
    - ARM_Deployments/AppGateway/*

variables:
  # Azure Connection Settings - UPDATE THESE VALUES
  azureServiceConnection: 'MSFT-NonProd-DevOpsConnection'  # Update with your service connection name
  subscriptionId: 'f16506c7-8141-4ef7-8a2e-67f11b6f8acd'             # Update with your subscription ID
  
  # Resource Settings
  resourceGroupName: 'rg-appgateway-nonprod'
  location: 'eastus'
  
  # Template Files
  templateFile: 'ARM_Deployments/AppGateway/ApplicationGateway.json'
  parametersFile: 'ARM_Deployments/AppGateway/parameters.json'
  
  # Deployment Settings
  deploymentName: 'AppGateway-$(Build.BuildId)'
  
  # Application Gateway Configuration (these will override parameters.json if needed)
  applicationGatewayName: 'agw-benruggiero-nonprod'
  virtualNetworkName: 'vnet-benruggiero-nonprod'
  subnetName: 'snet-appgateway'
  publicIPName: 'pip-appgateway-nonprod'
  backendIPAddress: '10.10.2.10'
  subnetAddressPrefix: '10.10.1.32/27'
  vnetAddressPrefix: '10.10.0.0/22'

stages:
- stage: Validate
  displayName: 'üîç Validate ARM Template'
  jobs:
  - job: ValidateTemplate
    displayName: 'Validate Application Gateway Template'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: AzureCLI@2
      displayName: 'Validate ARM Template Syntax'
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "üîç Validating ARM template syntax..."
          echo "üèóÔ∏è Creating resource group for validation..."
          az group create --name $(resourceGroupName) --location "$(location)" --output table
          
          az deployment group validate \
            --resource-group $(resourceGroupName) \
            --template-file $(templateFile) \
            --parameters applicationGatewayName="$(applicationGatewayName)" \
            --parameters virtualNetworkName="$(virtualNetworkName)" \
            --parameters subnetName="$(subnetName)" \
            --parameters publicIPName="$(publicIPName)" \
            --parameters backendIPAddress="$(backendIPAddress)" \
            --parameters subnetAddressPrefix="$(subnetAddressPrefix)" \
            --parameters vnetAddressPrefix="$(vnetAddressPrefix)" \
            --parameters location="$(location)"
          
          echo "‚úÖ Template validation completed successfully!"

    - task: PowerShell@2
      displayName: 'Display Configuration'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üéØ Deployment Configuration:" -ForegroundColor Cyan
          Write-Host "=============================" -ForegroundColor Cyan
          Write-Host "Application Gateway: $(applicationGatewayName)" -ForegroundColor White
          Write-Host "Virtual Network: $(virtualNetworkName)" -ForegroundColor White
          Write-Host "Subnet: $(subnetName) ($(subnetAddressPrefix))" -ForegroundColor White
          Write-Host "VNet Range: $(vnetAddressPrefix)" -ForegroundColor White
          Write-Host "Backend IP: $(backendIPAddress)" -ForegroundColor White
          Write-Host "Public IP: $(publicIPName)" -ForegroundColor White
          Write-Host "Resource Group: $(resourceGroupName)" -ForegroundColor White
          Write-Host "Location: $(location)" -ForegroundColor White

- stage: Deploy
  displayName: 'üöÄ Deploy to Azure'
  dependsOn: Validate
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployAppGateway
    displayName: 'Deploy Application Gateway'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'nonprod-azure'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: AzureCLI@2
            displayName: 'Create Resource Group (if needed)'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "üèóÔ∏è Ensuring resource group exists..."
                az group create --name $(resourceGroupName) --location "$(location)" --output table
                echo "‚úÖ Resource group ready!"
          
          - task: AzureCLI@2
            displayName: 'Deploy Application Gateway'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "üöÄ Starting ARM template deployment..."
                echo "üìÅ Template: $(templateFile)"
                echo "üè∑Ô∏è  Deployment Name: $(deploymentName)"
                echo "üìç Resource Group: $(resourceGroupName)"
                echo "üåç Location: $(location)"
                echo ""
                echo "üìã Parameters being passed:"
                echo "  applicationGatewayName: $(applicationGatewayName)"
                echo "  virtualNetworkName: $(virtualNetworkName)"
                echo "  subnetName: $(subnetName)"
                echo "  publicIPName: $(publicIPName)"
                echo "  backendIPAddress: $(backendIPAddress)"
                echo "  subnetAddressPrefix: $(subnetAddressPrefix)"
                echo "  vnetAddressPrefix: $(vnetAddressPrefix)"
                echo "  location: $(location)"
                echo ""
                
                # First, let's validate again before deploying
                echo "üîç Final validation before deployment..."
                az deployment group validate \
                  --resource-group "$(resourceGroupName)" \
                  --template-file "$(templateFile)" \
                  --parameters applicationGatewayName="$(applicationGatewayName)" \
                  --parameters virtualNetworkName="$(virtualNetworkName)" \
                  --parameters subnetName="$(subnetName)" \
                  --parameters publicIPName="$(publicIPName)" \
                  --parameters backendIPAddress="$(backendIPAddress)" \
                  --parameters subnetAddressPrefix="$(subnetAddressPrefix)" \
                  --parameters vnetAddressPrefix="$(vnetAddressPrefix)" \
                  --parameters location="$(location)" \
                  --verbose
                
                if [ $? -ne 0 ]; then
                  echo "‚ùå Validation failed! Stopping deployment."
                  exit 1
                fi
                
                echo "‚úÖ Validation passed. Starting deployment..."
                echo ""
                
                # Deploy the ARM template using Azure CLI with detailed error output
                az deployment group create \
                  --resource-group "$(resourceGroupName)" \
                  --template-file "$(templateFile)" \
                  --name "$(deploymentName)" \
                  --parameters applicationGatewayName="$(applicationGatewayName)" \
                  --parameters virtualNetworkName="$(virtualNetworkName)" \
                  --parameters subnetName="$(subnetName)" \
                  --parameters publicIPName="$(publicIPName)" \
                  --parameters backendIPAddress="$(backendIPAddress)" \
                  --parameters subnetAddressPrefix="$(subnetAddressPrefix)" \
                  --parameters vnetAddressPrefix="$(vnetAddressPrefix)" \
                  --parameters location="$(location)" \
                  --verbose \
                  --debug
                
                DEPLOYMENT_EXIT_CODE=$?
                
                if [ $DEPLOYMENT_EXIT_CODE -ne 0 ]; then
                  echo ""
                  echo "‚ùå Deployment failed with exit code: $DEPLOYMENT_EXIT_CODE"
                  echo "üîç Getting deployment error details..."
                  
                  # Get detailed error information
                  az deployment group show \
                    --resource-group "$(resourceGroupName)" \
                    --name "$(deploymentName)" \
                    --query '{
                      provisioningState: properties.provisioningState,
                      error: properties.error,
                      timestamp: properties.timestamp
                    }' \
                    --output json
                  
                  # Get deployment operations to see which resource failed
                  echo ""
                  echo "üîç Deployment operations:"
                  az deployment operation group list \
                    --resource-group "$(resourceGroupName)" \
                    --name "$(deploymentName)" \
                    --query '[].{
                      operationId: operationId,
                      provisioningState: properties.provisioningState,
                      resourceType: properties.targetResource.resourceType,
                      resourceName: properties.targetResource.resourceName,
                      statusCode: properties.statusCode,
                      statusMessage: properties.statusMessage.error.message
                    }' \
                    --output table
                  
                  exit $DEPLOYMENT_EXIT_CODE
                fi
                
                echo "‚úÖ Deployment completed successfully!"
                
                # Get deployment outputs
                echo "üì§ Deployment outputs:"
                az deployment group show \
                  --resource-group "$(resourceGroupName)" \
                  --name "$(deploymentName)" \
                  --query properties.outputs \
                  --output table
          
          - task: PowerShell@2
            displayName: 'üìä Display Deployment Results'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "üìä Deployment Results:" -ForegroundColor Cyan
                Write-Host "======================" -ForegroundColor Cyan
                
                try {
                    $outputs = '$(deploymentOutputs)' | ConvertFrom-Json
                    $outputs.PSObject.Properties | ForEach-Object {
                        Write-Host "  $($_.Name): $($_.Value.value)" -ForegroundColor White
                    }
                    
                    # Set output variables for next stage
                    if ($outputs.publicIPAddress) {
                        Write-Host "##vso[task.setvariable variable=publicIPAddress;isOutput=true]$($outputs.publicIPAddress.value)"
                    }
                    if ($outputs.applicationGatewayName) {
                        Write-Host "##vso[task.setvariable variable=deployedAppGatewayName;isOutput=true]$($outputs.applicationGatewayName.value)"
                    }
                    if ($outputs.virtualNetworkName) {
                        Write-Host "##vso[task.setvariable variable=deployedVNetName;isOutput=true]$($outputs.virtualNetworkName.value)"
                    }
                    
                    Write-Host ""
                    Write-Host "‚úÖ Deployment completed successfully!" -ForegroundColor Green
                }
                catch {
                    Write-Host "‚ö†Ô∏è Could not parse deployment outputs: $_" -ForegroundColor Yellow
                }

- stage: PostDeploy
  displayName: '‚úÖ Post-Deployment Validation'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: ValidateDeployment
    displayName: 'Validate and Test Deployment'
    pool:
      vmImage: 'ubuntu-latest'
    variables:
      publicIPAddress: $[ stageDependencies.Deploy.DeployAppGateway.outputs['DeployAppGateway.publicIPAddress'] ]
      deployedAppGatewayName: $[ stageDependencies.Deploy.DeployAppGateway.outputs['DeployAppGateway.deployedAppGatewayName'] ]
      deployedVNetName: $[ stageDependencies.Deploy.DeployAppGateway.outputs['DeployAppGateway.deployedVNetName'] ]
    
    steps:
    - task: AzureCLI@2
      displayName: 'üîç Check Application Gateway Status'
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "üîç Application Gateway Status Check"
          echo "==================================="
          
          # Get Application Gateway details
          echo "üìã Application Gateway Details:"
          az network application-gateway show \
            --name $(applicationGatewayName) \
            --resource-group $(resourceGroupName) \
            --query '{
              name: name,
              location: location,
              provisioningState: provisioningState,
              operationalState: operationalState,
              sku: sku.name,
              tier: sku.tier,
              capacity: sku.capacity,
              autoscale: autoscaleConfiguration
            }' \
            --output table
          
          echo ""
          echo "üåê Public IP Details:"
          az network public-ip show \
            --name $(publicIPName) \
            --resource-group $(resourceGroupName) \
            --query '{
              name: name,
              ipAddress: ipAddress,
              allocationMethod: publicIPAllocationMethod,
              sku: sku.name
            }' \
            --output table
          
          echo ""
          echo "üèóÔ∏è Virtual Network Details:"
          az network vnet show \
            --name $(virtualNetworkName) \
            --resource-group $(resourceGroupName) \
            --query '{
              name: name,
              addressSpace: addressSpace.addressPrefixes[0],
              subnets: length(subnets)
            }' \
            --output table
    
    - task: AzureCLI@2
      displayName: 'üè• Check Backend Health'
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "üè• Backend Health Status"
          echo "========================"
          
          # Check backend health
          health_output=$(az network application-gateway show-backend-health \
            --name $(applicationGatewayName) \
            --resource-group $(resourceGroupName) \
            --output json 2>/dev/null || echo "[]")
          
          if [ "$health_output" = "[]" ]; then
            echo "‚ö†Ô∏è No backend health data available yet (this is normal for new deployments)"
            echo "   Backend health will be available once the Application Gateway is fully operational"
          else
            echo "$health_output" | jq -r '.backendAddressPools[0].backendHttpSettingsCollection[0].servers[] | "Backend: \(.address) - Health: \(.health)"'
          fi
    
    - task: PowerShell@2
      displayName: 'üåê Test Connectivity'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üåê Testing Application Gateway Connectivity" -ForegroundColor Cyan
          Write-Host "==========================================" -ForegroundColor Cyan
          
          $publicIP = "$(publicIPAddress)"
          if ([string]::IsNullOrEmpty($publicIP)) {
            $publicIP = "$(System.DefaultWorkingDirectory)/outputs not available"
          }
          
          Write-Host "Public IP Address: $publicIP" -ForegroundColor White
          Write-Host "Test URL: http://$publicIP" -ForegroundColor White
          Write-Host ""
          
          if ($publicIP -match '^\d+\.\d+\.\d+\.\d+$') {
            try {
              Write-Host "üîÑ Testing HTTP connectivity..." -ForegroundColor Yellow
              $response = Invoke-WebRequest -Uri "http://$publicIP" -Method GET -TimeoutSec 10 -ErrorAction Stop
              Write-Host "‚úÖ HTTP connectivity test successful!" -ForegroundColor Green
              Write-Host "   Status Code: $($response.StatusCode)" -ForegroundColor White
              Write-Host "   Status Description: $($response.StatusDescription)" -ForegroundColor White
            }
            catch {
              Write-Host "‚ö†Ô∏è HTTP connectivity test failed (expected if backend not configured)" -ForegroundColor Yellow
              Write-Host "   Error: $($_.Exception.Message)" -ForegroundColor Yellow
              Write-Host "   This is normal for a new Application Gateway without configured backends" -ForegroundColor Yellow
            }
          } else {
            Write-Host "‚ö†Ô∏è Could not retrieve public IP address for testing" -ForegroundColor Yellow
          }
          
          Write-Host ""
          Write-Host "üéØ Next Steps:" -ForegroundColor Cyan
          Write-Host "=============" -ForegroundColor Cyan
          Write-Host "1. Configure your backend servers to respond on port 80" -ForegroundColor White
          Write-Host "2. Ensure backend servers are reachable from subnet $(subnetAddressPrefix)" -ForegroundColor White
          Write-Host "3. Set up custom health probes if needed" -ForegroundColor White
          Write-Host "4. Configure SSL certificates for HTTPS" -ForegroundColor White
          Write-Host "5. Set up monitoring and alerts" -ForegroundColor White

- stage: Cleanup
  displayName: 'üßπ Cleanup (Manual Trigger Only)'
  dependsOn: []
  condition: and(always(), eq(variables['Build.Reason'], 'Manual'))
  jobs:
  - job: ManualCleanup
    displayName: 'Manual Resource Cleanup'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: PowerShell@2
      displayName: '‚ö†Ô∏è Cleanup Warning'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "‚ö†Ô∏è CLEANUP STAGE" -ForegroundColor Red
          Write-Host "================" -ForegroundColor Red
          Write-Host "This stage is for manual cleanup only!" -ForegroundColor Yellow
          Write-Host "To actually delete resources, enable the cleanup task below." -ForegroundColor Yellow
          Write-Host ""
          Write-Host "Resources that would be deleted:" -ForegroundColor White
          Write-Host "- Application Gateway: $(applicationGatewayName)" -ForegroundColor White
          Write-Host "- Public IP: $(publicIPName)" -ForegroundColor White
          Write-Host "- Virtual Network: $(virtualNetworkName)" -ForegroundColor White
          Write-Host "- Resource Group: $(resourceGroupName)" -ForegroundColor White
    
    # Uncomment the task below to enable actual cleanup
    # - task: AzureCLI@2
    #   displayName: 'üóëÔ∏è Delete Resources'
    #   inputs:
    #     azureSubscription: '$(azureServiceConnection)'
    #     scriptType: 'bash'
    #     scriptLocation: 'inlineScript'
    #     inlineScript: |
    #       echo "üóëÔ∏è Deleting Application Gateway resources..."
    #       az group delete --name $(resourceGroupName) --yes --no-wait
    #       echo "‚úÖ Cleanup initiated!"
